"""Git operations for code execution and branch management."""

import subprocess
import os
from typing import List, Optional, Dict, Any
from dataclasses import dataclass
from pathlib import Path
from datetime import datetime, timezone

from ..core.logger import AuditLogger, EventType


@dataclass
class GitStatus:
    """Current git repository status."""
    current_branch: str
    has_uncommitted_changes: bool
    staged_files: List[str]
    unstaged_files: List[str]
    untracked_files: List[str]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "current_branch": self.current_branch,
            "has_uncommitted_changes": self.has_uncommitted_changes,
            "staged_files": self.staged_files,
            "unstaged_files": self.unstaged_files,
            "untracked_files": self.untracked_files,
        }


@dataclass
class CommitInfo:
    """Information about a git commit."""
    commit_hash: str
    message: str
    author: str
    timestamp: datetime
    files_changed: List[str]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "commit_hash": self.commit_hash,
            "message": self.message,
            "author": self.author,
            "timestamp": self.timestamp.isoformat(),
            "files_changed": self.files_changed,
        }


class GitOpsError(Exception):
    """Base exception for git operations."""
    pass


class GitBranchError(GitOpsError):
    """Exception for branch operations."""
    pass


class GitCommitError(GitOpsError):
    """Exception for commit operations."""
    pass


class GitOps:
    """Git operations manager for code execution.

    Handles:
    - Branch creation and switching
    - File staging and commits
    - Status checking
    - Commit message generation
    - Repository state management
    """

    # Orchestrator signature for commits
    ORCHESTRATOR_SIGNATURE = "\n\nðŸ¤– Generated by Self-Reflexive Orchestrator\nCo-Authored-By: Orchestrator <noreply@orchestrator.dev>"

    def __init__(
        self,
        repo_path: str,
        logger: AuditLogger,
        base_branch: str = "main",
    ):
        """Initialize git operations manager.

        Args:
            repo_path: Path to git repository
            logger: Audit logger instance
            base_branch: Base branch to create feature branches from
        """
        self.repo_path = Path(repo_path).resolve()
        self.logger = logger
        self.base_branch = base_branch

        # Verify it's a git repository
        if not (self.repo_path / ".git").exists():
            raise GitOpsError(f"Not a git repository: {repo_path}")

    def get_status(self) -> GitStatus:
        """Get current git repository status.

        Returns:
            GitStatus with current repository state
        """
        try:
            # Get current branch
            result = self._run_git_command(["rev-parse", "--abbrev-ref", "HEAD"])
            current_branch = result.strip()

            # Get staged files
            result = self._run_git_command(["diff", "--name-only", "--cached"])
            staged_files = [f.strip() for f in result.split("\n") if f.strip()]

            # Get unstaged modified files
            result = self._run_git_command(["diff", "--name-only"])
            unstaged_files = [f.strip() for f in result.split("\n") if f.strip()]

            # Get untracked files
            result = self._run_git_command(["ls-files", "--others", "--exclude-standard"])
            untracked_files = [f.strip() for f in result.split("\n") if f.strip()]

            has_uncommitted = bool(staged_files or unstaged_files or untracked_files)

            status = GitStatus(
                current_branch=current_branch,
                has_uncommitted_changes=has_uncommitted,
                staged_files=staged_files,
                unstaged_files=unstaged_files,
                untracked_files=untracked_files,
            )

            self.logger.debug(
                "Git status retrieved",
                branch=current_branch,
                has_changes=has_uncommitted,
            )

            return status

        except subprocess.CalledProcessError as e:
            raise GitOpsError(f"Failed to get git status: {e.stderr}")

    def create_branch(self, branch_name: str, from_branch: Optional[str] = None) -> str:
        """Create a new git branch.

        Args:
            branch_name: Name of branch to create
            from_branch: Branch to create from (defaults to base_branch)

        Returns:
            Name of created branch

        Raises:
            GitBranchError: If branch creation fails
        """
        from_branch = from_branch or self.base_branch

        try:
            # Ensure we're on the base branch
            self._run_git_command(["checkout", from_branch])

            # Pull latest changes
            self._run_git_command(["pull", "origin", from_branch])

            # Create and checkout new branch
            self._run_git_command(["checkout", "-b", branch_name])

            self.logger.info(
                "Created git branch",
                branch=branch_name,
                from_branch=from_branch,
                event_type=EventType.BRANCH_CREATED,
            )

            return branch_name

        except subprocess.CalledProcessError as e:
            raise GitBranchError(f"Failed to create branch {branch_name}: {e.stderr}")

    def switch_branch(self, branch_name: str) -> None:
        """Switch to an existing branch.

        Args:
            branch_name: Name of branch to switch to

        Raises:
            GitBranchError: If branch switch fails
        """
        try:
            self._run_git_command(["checkout", branch_name])

            self.logger.debug(
                "Switched to branch",
                branch=branch_name,
            )

        except subprocess.CalledProcessError as e:
            raise GitBranchError(f"Failed to switch to branch {branch_name}: {e.stderr}")

    def stage_files(self, file_paths: List[str]) -> None:
        """Stage files for commit.

        Args:
            file_paths: List of file paths to stage

        Raises:
            GitOpsError: If staging fails
        """
        if not file_paths:
            return

        try:
            self._run_git_command(["add"] + file_paths)

            self.logger.debug(
                "Staged files",
                files=file_paths,
                count=len(file_paths),
            )

        except subprocess.CalledProcessError as e:
            raise GitOpsError(f"Failed to stage files: {e.stderr}")

    def commit(
        self,
        message: str,
        file_paths: Optional[List[str]] = None,
        add_signature: bool = True,
    ) -> CommitInfo:
        """Commit staged changes.

        Args:
            message: Commit message
            file_paths: Optional list of specific files to commit
            add_signature: Whether to add orchestrator signature

        Returns:
            CommitInfo with details of created commit

        Raises:
            GitCommitError: If commit fails
        """
        try:
            # Stage specific files if provided
            if file_paths:
                self.stage_files(file_paths)

            # Add signature if requested
            full_message = message
            if add_signature and self.ORCHESTRATOR_SIGNATURE not in message:
                full_message = message + self.ORCHESTRATOR_SIGNATURE

            # Create commit
            self._run_git_command(["commit", "-m", full_message])

            # Get commit info
            commit_info = self.get_last_commit()

            self.logger.info(
                "Created git commit",
                commit_hash=commit_info.commit_hash,
                message=message,
                files_count=len(commit_info.files_changed),
                event_type=EventType.CODE_COMMITTED,
            )

            return commit_info

        except subprocess.CalledProcessError as e:
            raise GitCommitError(f"Failed to commit: {e.stderr}")

    def get_last_commit(self) -> CommitInfo:
        """Get information about the last commit.

        Returns:
            CommitInfo for the most recent commit
        """
        try:
            # Get commit hash
            commit_hash = self._run_git_command(["rev-parse", "HEAD"]).strip()

            # Get commit message
            message = self._run_git_command(["log", "-1", "--pretty=%B"]).strip()

            # Get author
            author = self._run_git_command(["log", "-1", "--pretty=%an <%ae>"]).strip()

            # Get timestamp
            timestamp_str = self._run_git_command(["log", "-1", "--pretty=%cI"]).strip()
            timestamp = datetime.fromisoformat(timestamp_str.replace("Z", "+00:00"))

            # Get files changed
            files_output = self._run_git_command(["diff-tree", "--no-commit-id", "--name-only", "-r", commit_hash])
            files_changed = [f.strip() for f in files_output.split("\n") if f.strip()]

            return CommitInfo(
                commit_hash=commit_hash,
                message=message,
                author=author,
                timestamp=timestamp,
                files_changed=files_changed,
            )

        except subprocess.CalledProcessError as e:
            raise GitOpsError(f"Failed to get last commit: {e.stderr}")

    def push_branch(self, branch_name: Optional[str] = None, set_upstream: bool = True) -> None:
        """Push branch to remote.

        Args:
            branch_name: Branch to push (None = current branch)
            set_upstream: Whether to set upstream tracking

        Raises:
            GitOpsError: If push fails
        """
        try:
            if branch_name:
                current_branch = self.get_status().current_branch
                if current_branch != branch_name:
                    self.switch_branch(branch_name)

            cmd = ["push"]
            if set_upstream:
                cmd.extend(["-u", "origin", "HEAD"])
            else:
                cmd.append("origin")

            self._run_git_command(cmd)

            self.logger.info(
                "Pushed branch to remote",
                branch=branch_name or "current",
                set_upstream=set_upstream,
            )

        except subprocess.CalledProcessError as e:
            raise GitOpsError(f"Failed to push branch: {e.stderr}")

    def has_uncommitted_changes(self) -> bool:
        """Check if repository has uncommitted changes.

        Returns:
            True if there are uncommitted changes
        """
        status = self.get_status()
        return status.has_uncommitted_changes

    def get_current_branch(self) -> str:
        """Get name of current branch.

        Returns:
            Current branch name
        """
        return self.get_status().current_branch

    def branch_exists(self, branch_name: str) -> bool:
        """Check if a branch exists locally.

        Args:
            branch_name: Name of branch to check

        Returns:
            True if branch exists
        """
        try:
            self._run_git_command(["rev-parse", "--verify", branch_name])
            return True
        except subprocess.CalledProcessError:
            return False

    def delete_branch(self, branch_name: str, force: bool = False) -> None:
        """Delete a local branch.

        Args:
            branch_name: Name of branch to delete
            force: Whether to force delete

        Raises:
            GitBranchError: If deletion fails
        """
        try:
            flag = "-D" if force else "-d"
            self._run_git_command(["branch", flag, branch_name])

            self.logger.info(
                "Deleted branch",
                branch=branch_name,
                force=force,
            )

        except subprocess.CalledProcessError as e:
            raise GitBranchError(f"Failed to delete branch {branch_name}: {e.stderr}")

    def get_diff(
        self,
        file_path: Optional[str] = None,
        staged: bool = False,
    ) -> str:
        """Get diff of changes.

        Args:
            file_path: Optional specific file to get diff for
            staged: Whether to get staged diff (vs unstaged)

        Returns:
            Diff output as string
        """
        try:
            cmd = ["diff"]
            if staged:
                cmd.append("--cached")
            if file_path:
                cmd.append(file_path)

            diff = self._run_git_command(cmd)
            return diff

        except subprocess.CalledProcessError as e:
            raise GitOpsError(f"Failed to get diff: {e.stderr}")

    def reset_hard(self, ref: str = "HEAD") -> None:
        """Hard reset to a specific ref.

        Args:
            ref: Git reference to reset to (default: HEAD)

        Raises:
            GitOpsError: If reset fails
        """
        try:
            self._run_git_command(["reset", "--hard", ref])

            self.logger.warning(
                "Performed hard reset",
                ref=ref,
            )

        except subprocess.CalledProcessError as e:
            raise GitOpsError(f"Failed to reset: {e.stderr}")

    def _run_git_command(self, args: List[str]) -> str:
        """Run a git command in the repository.

        Args:
            args: Git command arguments (without 'git' prefix)

        Returns:
            Command output as string

        Raises:
            subprocess.CalledProcessError: If command fails
        """
        cmd = ["git"] + args

        result = subprocess.run(
            cmd,
            cwd=str(self.repo_path),
            capture_output=True,
            text=True,
            check=True,
        )

        return result.stdout

    def generate_commit_message(
        self,
        issue_number: int,
        step_description: str,
        files_changed: List[str],
    ) -> str:
        """Generate a descriptive commit message.

        Args:
            issue_number: GitHub issue number
            step_description: Description of implementation step
            files_changed: List of files being committed

        Returns:
            Formatted commit message
        """
        # Extract main action from step description
        action = step_description.split('.')[0] if '.' in step_description else step_description

        # Determine scope from files
        scope = self._determine_scope(files_changed)

        # Build commit message
        subject = f"{action}"
        if scope:
            subject = f"{scope}: {action}"

        body_parts = [
            f"Issue: #{issue_number}",
            f"Step: {step_description}",
        ]

        if files_changed:
            body_parts.append(f"Files modified: {', '.join(files_changed[:5])}")
            if len(files_changed) > 5:
                body_parts.append(f"... and {len(files_changed) - 5} more")

        body = "\n".join(body_parts)

        return f"{subject}\n\n{body}"

    def _determine_scope(self, files: List[str]) -> Optional[str]:
        """Determine commit scope from modified files.

        Args:
            files: List of file paths

        Returns:
            Scope string or None
        """
        if not files:
            return None

        # Analyze file paths for common directories
        scopes = {
            "src/analyzers": "analyzers",
            "src/cycles": "cycles",
            "src/integrations": "integrations",
            "src/core": "core",
            "tests/unit": "tests",
            "tests/integration": "tests",
            "docs": "docs",
        }

        for file_path in files:
            for prefix, scope in scopes.items():
                if file_path.startswith(prefix):
                    return scope

        return None
