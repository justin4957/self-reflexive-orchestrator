"""PR creation and management cycle.

Handles creating pull requests with comprehensive descriptions,
linking to issues, managing labels and reviewers, and code review integration.
"""

from typing import List, Optional, Dict, Any
from dataclasses import dataclass, field
from pathlib import Path
from datetime import datetime, timezone

from ..integrations.git_ops import GitOps
from ..integrations.github_client import GitHubClient
from ..integrations.multi_agent_coder_client import (
    MultiAgentCoderClient,
    PRReviewResult,
    ReviewComment,
)
from ..analyzers.implementation_planner import ImplementationPlan
from ..integrations.test_runner import TestResult
from ..core.logger import AuditLogger, EventType
from ..core.state import WorkItem


@dataclass
class PRDetails:
    """Details for creating a pull request."""

    title: str
    body: str
    head_branch: str
    base_branch: str = "main"
    draft: bool = False
    labels: List[str] = field(default_factory=list)
    reviewers: List[str] = field(default_factory=list)
    issue_number: Optional[int] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "title": self.title,
            "body_length": len(self.body),
            "head_branch": self.head_branch,
            "base_branch": self.base_branch,
            "draft": self.draft,
            "labels": self.labels,
            "reviewers": self.reviewers,
            "issue_number": self.issue_number,
        }


@dataclass
class PRCreationResult:
    """Result of PR creation."""

    pr_number: int
    pr_url: str
    success: bool
    branch_pushed: bool
    pr_details: PRDetails
    error: Optional[str] = None
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "pr_number": self.pr_number,
            "pr_url": self.pr_url,
            "success": self.success,
            "branch_pushed": self.branch_pushed,
            "pr_details": self.pr_details.to_dict(),
            "error": self.error,
            "created_at": self.created_at.isoformat(),
        }


class PRCreator:
    """Creates pull requests with comprehensive descriptions.

    Responsibilities:
    - Generate PR titles and descriptions
    - Push feature branches to remote
    - Create PRs with proper formatting
    - Add labels and request reviews
    - Link PRs to issues
    - Handle errors gracefully
    """

    # Default PR labels by issue type
    DEFAULT_LABELS = {
        "feature": ["enhancement", "orchestrator"],
        "bug": ["bug", "orchestrator"],
        "refactor": ["refactor", "orchestrator"],
        "documentation": ["documentation", "orchestrator"],
    }

    # PR description template
    PR_TEMPLATE = """## Summary
{summary}

## Related Issue
Closes #{issue_number}

## Changes Made
{changes_made}

## Test Results
{test_results}

## Implementation Details
{implementation_details}

## Checklist
- [ ] Code follows project style guidelines
- [ ] Tests added/updated and passing
- [ ] Documentation updated if needed
- [ ] No breaking changes (or documented if unavoidable)

ðŸ¤– Generated by [Self-Reflexive Orchestrator](https://github.com/justin4957/self-reflexive-orchestrator)
"""

    def __init__(
        self,
        git_ops: GitOps,
        github_client: GitHubClient,
        logger: AuditLogger,
        default_base_branch: str = "main",
        default_reviewers: Optional[List[str]] = None,
    ):
        """Initialize PR creator.

        Args:
            git_ops: Git operations client
            github_client: GitHub API client
            logger: Audit logger
            default_base_branch: Default base branch for PRs
            default_reviewers: Default list of reviewers
        """
        self.git_ops = git_ops
        self.github_client = github_client
        self.logger = logger
        self.default_base_branch = default_base_branch
        self.default_reviewers = default_reviewers or []

        # Statistics
        self.total_prs_created = 0
        self.successful_prs = 0
        self.failed_prs = 0

    def create_pr_from_work_item(
        self,
        work_item: WorkItem,
        plan: ImplementationPlan,
        test_result: Optional[TestResult] = None,
        additional_context: Optional[str] = None,
    ) -> PRCreationResult:
        """Create PR from work item and implementation plan.

        Args:
            work_item: Work item with issue information
            plan: Implementation plan with changes
            test_result: Optional test results
            additional_context: Additional context for PR description

        Returns:
            PRCreationResult with PR information
        """
        issue_number = work_item.metadata.get("issue_number", int(work_item.item_id))

        self.logger.info(
            "Creating PR from work item",
            issue_number=issue_number,
            branch=plan.branch_name,
        )

        try:
            # Generate PR details
            pr_details = self._generate_pr_details(
                work_item=work_item,
                plan=plan,
                test_result=test_result,
                additional_context=additional_context,
            )

            # Push branch to remote
            branch_pushed = self._push_branch(pr_details.head_branch)

            if not branch_pushed:
                return PRCreationResult(
                    pr_number=0,
                    pr_url="",
                    success=False,
                    branch_pushed=False,
                    pr_details=pr_details,
                    error="Failed to push branch to remote",
                )

            # Create PR
            pr = self.github_client.create_pull_request(
                title=pr_details.title,
                body=pr_details.body,
                head=pr_details.head_branch,
                base=pr_details.base_branch,
                draft=pr_details.draft,
            )

            # Add labels if specified
            if pr_details.labels:
                self._add_labels(pr.number, pr_details.labels)

            # Request reviews if specified
            if pr_details.reviewers:
                self._request_reviews(pr.number, pr_details.reviewers)

            # Update statistics
            self.total_prs_created += 1
            self.successful_prs += 1

            self.logger.audit(
                EventType.PR_CREATED,
                f"Created PR #{pr.number} for issue #{issue_number}",
                resource_type="pr",
                resource_id=str(pr.number),
                metadata={
                    "issue_number": issue_number,
                    "branch": pr_details.head_branch,
                    "url": pr.html_url,
                },
            )

            return PRCreationResult(
                pr_number=pr.number,
                pr_url=pr.html_url,
                success=True,
                branch_pushed=True,
                pr_details=pr_details,
            )

        except Exception as e:
            self.failed_prs += 1
            self.total_prs_created += 1

            self.logger.error(
                "Failed to create PR",
                issue_number=(
                    issue_number if "issue_number" in locals() else work_item.item_id
                ),
                error=str(e),
                exc_info=True,
            )

            return PRCreationResult(
                pr_number=0,
                pr_url="",
                success=False,
                branch_pushed=branch_pushed if "branch_pushed" in locals() else False,
                pr_details=pr_details if "pr_details" in locals() else None,
                error=str(e),
            )

    def _generate_pr_details(
        self,
        work_item: WorkItem,
        plan: ImplementationPlan,
        test_result: Optional[TestResult],
        additional_context: Optional[str],
    ) -> PRDetails:
        """Generate PR details from work item and plan.

        Args:
            work_item: Work item with issue information
            plan: Implementation plan
            test_result: Optional test results
            additional_context: Additional context

        Returns:
            PRDetails for PR creation
        """
        # Generate title
        title = self._generate_pr_title(work_item, plan)

        # Generate body
        body = self._generate_pr_body(
            work_item=work_item,
            plan=plan,
            test_result=test_result,
            additional_context=additional_context,
        )

        # Determine labels
        labels = self._determine_labels(work_item)

        # Get reviewers
        reviewers = self.default_reviewers.copy()

        issue_number = work_item.metadata.get("issue_number", int(work_item.item_id))

        return PRDetails(
            title=title,
            body=body,
            head_branch=plan.branch_name,
            base_branch=self.default_base_branch,
            draft=False,
            labels=labels,
            reviewers=reviewers,
            issue_number=issue_number,
        )

    def _generate_pr_title(self, work_item: WorkItem, plan: ImplementationPlan) -> str:
        """Generate PR title.

        Args:
            work_item: Work item
            plan: Implementation plan

        Returns:
            PR title
        """
        # Use issue title directly, prefixed with phase/type if available
        issue_number = work_item.metadata.get("issue_number", int(work_item.item_id))
        title = work_item.metadata.get("title", f"Issue #{issue_number}")

        # Add phase prefix if present in title
        if not title.startswith("["):
            issue_type = work_item.metadata.get("issue_type", "")
            if issue_type:
                title = f"[{issue_type.title()}] {title}"

        return title

    def _generate_pr_body(
        self,
        work_item: WorkItem,
        plan: ImplementationPlan,
        test_result: Optional[TestResult],
        additional_context: Optional[str],
    ) -> str:
        """Generate comprehensive PR body.

        Args:
            work_item: Work item
            plan: Implementation plan
            test_result: Test results
            additional_context: Additional context

        Returns:
            Formatted PR body
        """
        # Summary
        summary = work_item.metadata.get("description", plan.pr_description)

        # Changes made
        changes_made = self._format_changes_made(plan)

        # Test results
        test_results = self._format_test_results(test_result)

        # Implementation details
        implementation_details = self._format_implementation_details(
            plan, additional_context
        )

        issue_number = work_item.metadata.get("issue_number", int(work_item.item_id))

        # Fill template
        body = self.PR_TEMPLATE.format(
            summary=summary,
            issue_number=issue_number,
            changes_made=changes_made,
            test_results=test_results,
            implementation_details=implementation_details,
        )

        return body

    def _format_changes_made(self, plan: ImplementationPlan) -> str:
        """Format changes made section.

        Args:
            plan: Implementation plan

        Returns:
            Formatted changes list
        """
        lines = []

        if plan.files_to_create:
            lines.append("### Files Created")
            for file in plan.files_to_create:
                lines.append(f"- `{file}`: New file")

        if plan.files_to_modify:
            lines.append("\n### Files Modified")
            for file in plan.files_to_modify:
                lines.append(f"- `{file}`: Updated")

        if plan.implementation_steps:
            lines.append("\n### Implementation Steps")
            for i, step in enumerate(plan.implementation_steps, 1):
                lines.append(f"{i}. {step.description}")

        return "\n".join(lines) if lines else "No files changed"

    def _format_test_results(self, test_result: Optional[TestResult]) -> str:
        """Format test results section.

        Args:
            test_result: Test results

        Returns:
            Formatted test results
        """
        if not test_result:
            return "â­ï¸ Tests not run yet"

        if test_result.success:
            return f"âœ… All tests passing ({test_result.passed} passed, {test_result.failed} failed, {test_result.skipped} skipped)"

        failures_text = ""
        if test_result.failures:
            failures_text = "\n\n**Failing Tests:**\n"
            for failure in test_result.failures[:5]:  # Show first 5 failures
                failures_text += f"- `{failure.test_name}`: {failure.error_message}\n"
            if len(test_result.failures) > 5:
                failures_text += f"- ... and {len(test_result.failures) - 5} more"

        return f"âŒ Tests failing ({test_result.passed} passed, {test_result.failed} failed){failures_text}"

    def _format_implementation_details(
        self,
        plan: ImplementationPlan,
        additional_context: Optional[str],
    ) -> str:
        """Format implementation details section.

        Args:
            plan: Implementation plan
            additional_context: Additional context

        Returns:
            Formatted implementation details
        """
        lines = []

        # Add plan description if available
        if plan.pr_description:
            lines.append(plan.pr_description)

        # Add test strategy
        if plan.test_strategy:
            lines.append(
                f"\n**Test Strategy:** {plan.test_strategy.coverage_requirements}"
            )

        # Add complexity estimate
        if plan.estimated_total_complexity > 0:
            complexity_level = (
                plan.confidence_level.value if plan.confidence_level else "unknown"
            )
            lines.append(
                f"\n**Complexity:** {plan.estimated_total_complexity}/10 ({complexity_level} confidence)"
            )

        # Add additional context
        if additional_context:
            lines.append(f"\n{additional_context}")

        return "\n".join(lines) if lines else "See implementation plan for details."

    def _determine_labels(self, work_item: WorkItem) -> List[str]:
        """Determine labels for PR based on work item.

        Args:
            work_item: Work item

        Returns:
            List of labels
        """
        labels = []

        # Get issue type from metadata
        issue_type = work_item.metadata.get("issue_type", "").lower()

        # Add default labels for issue type
        if issue_type in self.DEFAULT_LABELS:
            labels.extend(self.DEFAULT_LABELS[issue_type])
        else:
            labels.append("orchestrator")

        # Add phase label if present
        title = work_item.metadata.get("title", "")
        if "[Phase" in title:
            phase_match = title.split("]")[0].replace("[", "")
            labels.append(phase_match.lower().replace(" ", "-"))

        return list(set(labels))  # Remove duplicates

    def _push_branch(self, branch_name: str) -> bool:
        """Push branch to remote.

        Args:
            branch_name: Branch name to push

        Returns:
            True if successful, False otherwise
        """
        try:
            self.git_ops.push_branch(branch_name, set_upstream=True)
            self.logger.info("Branch pushed to remote", branch=branch_name)
            return True
        except Exception as e:
            self.logger.error(
                "Failed to push branch",
                branch=branch_name,
                error=str(e),
                exc_info=True,
            )
            return False

    def _add_labels(self, pr_number: int, labels: List[str]) -> None:
        """Add labels to PR.

        Args:
            pr_number: PR number
            labels: Labels to add
        """
        try:
            pr = self.github_client.get_pull_request(pr_number)
            pr.add_to_labels(*labels)
            self.logger.debug("Added labels to PR", pr_number=pr_number, labels=labels)
        except Exception as e:
            self.logger.warning(
                "Failed to add labels to PR",
                pr_number=pr_number,
                labels=labels,
                error=str(e),
            )

    def _request_reviews(self, pr_number: int, reviewers: List[str]) -> None:
        """Request reviews for PR.

        Args:
            pr_number: PR number
            reviewers: List of reviewer usernames
        """
        try:
            pr = self.github_client.get_pull_request(pr_number)
            pr.create_review_request(reviewers=reviewers)
            self.logger.debug(
                "Requested reviews for PR", pr_number=pr_number, reviewers=reviewers
            )
        except Exception as e:
            self.logger.warning(
                "Failed to request reviews",
                pr_number=pr_number,
                reviewers=reviewers,
                error=str(e),
            )

    def get_statistics(self) -> Dict[str, Any]:
        """Get PR creation statistics.

        Returns:
            Dictionary with statistics
        """
        success_rate = (
            (self.successful_prs / self.total_prs_created * 100)
            if self.total_prs_created > 0
            else 0.0
        )

        return {
            "total_prs_created": self.total_prs_created,
            "successful_prs": self.successful_prs,
            "failed_prs": self.failed_prs,
            "success_rate": success_rate,
        }

    def reset_statistics(self):
        """Reset PR creation statistics."""
        self.total_prs_created = 0
        self.successful_prs = 0
        self.failed_prs = 0


@dataclass
class CICheckStatus:
    """Status of a single CI check."""

    name: str
    status: str  # queued, in_progress, completed
    conclusion: Optional[str] = (
        None  # success, failure, neutral, cancelled, skipped, timed_out, action_required
    )
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    details_url: Optional[str] = None

    def is_passing(self) -> bool:
        """Check if this CI check is passing."""
        return self.status == "completed" and self.conclusion == "success"

    def is_failing(self) -> bool:
        """Check if this CI check is failing."""
        return self.status == "completed" and self.conclusion in [
            "failure",
            "timed_out",
            "action_required",
        ]

    def is_pending(self) -> bool:
        """Check if this CI check is still pending."""
        return self.status in ["queued", "in_progress"]


@dataclass
class CIStatus:
    """Overall CI status for a PR."""

    overall_status: str  # passed, failed, pending, no_checks
    checks: List[CICheckStatus] = field(default_factory=list)
    total_checks: int = 0
    passing_checks: int = 0
    failing_checks: int = 0
    pending_checks: int = 0
    checked_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

    def is_all_passing(self) -> bool:
        """Check if all CI checks are passing."""
        return self.overall_status == "passed"

    def has_failures(self) -> bool:
        """Check if any CI checks are failing."""
        return self.overall_status == "failed"

    def is_pending(self) -> bool:
        """Check if CI checks are still pending."""
        return self.overall_status == "pending"

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "overall_status": self.overall_status,
            "total_checks": self.total_checks,
            "passing_checks": self.passing_checks,
            "failing_checks": self.failing_checks,
            "pending_checks": self.pending_checks,
            "checked_at": self.checked_at.isoformat(),
            "checks": [
                {
                    "name": check.name,
                    "status": check.status,
                    "conclusion": check.conclusion,
                }
                for check in self.checks
            ],
        }


@dataclass
class CIMonitorResult:
    """Result of CI monitoring."""

    pr_number: int
    ci_status: CIStatus
    success: bool
    timed_out: bool = False
    wait_time: float = 0.0
    error: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "pr_number": self.pr_number,
            "ci_status": self.ci_status.to_dict(),
            "success": self.success,
            "timed_out": self.timed_out,
            "wait_time": self.wait_time,
            "error": self.error,
        }


class CIMonitor:
    """Monitors CI/CD checks for pull requests.

    Responsibilities:
    - Poll GitHub for CI check status
    - Support both check runs (GitHub Actions) and commit statuses (legacy CI)
    - Wait for checks to complete with timeout
    - Report overall CI status
    - Track CI monitoring statistics
    """

    def __init__(
        self,
        github_client: GitHubClient,
        logger: AuditLogger,
        poll_interval: int = 30,
        default_timeout: int = 1800,
    ):
        """Initialize CI monitor.

        Args:
            github_client: GitHub API client
            logger: Audit logger
            poll_interval: Seconds between status checks (default: 30)
            default_timeout: Default timeout in seconds (default: 1800 = 30 min)
        """
        self.github_client = github_client
        self.logger = logger
        self.poll_interval = poll_interval
        self.default_timeout = default_timeout

        # Statistics
        self.total_prs_monitored = 0
        self.prs_passed = 0
        self.prs_failed = 0
        self.prs_timed_out = 0

    def get_ci_status(self, pr_number: int) -> CIStatus:
        """Get current CI status for a PR.

        Args:
            pr_number: PR number to check

        Returns:
            CIStatus with current check status
        """
        try:
            self.logger.debug("Fetching CI status", pr_number=pr_number)

            # Get CI checks from GitHub client
            check_data = self.github_client.get_pr_checks(pr_number)

            # Parse checks into CICheckStatus objects
            checks = []
            for check in check_data.get("checks", []):
                checks.append(
                    CICheckStatus(
                        name=check.get("name", "Unknown"),
                        status=check.get("status", "unknown"),
                        conclusion=check.get("conclusion"),
                        started_at=self._parse_datetime(check.get("started_at")),
                        completed_at=self._parse_datetime(check.get("completed_at")),
                        details_url=check.get("details_url"),
                    )
                )

            # Calculate overall status
            total_checks = len(checks)
            passing_checks = sum(1 for c in checks if c.is_passing())
            failing_checks = sum(1 for c in checks if c.is_failing())
            pending_checks = sum(1 for c in checks if c.is_pending())

            # Determine overall status
            if total_checks == 0:
                overall_status = "no_checks"
            elif failing_checks > 0:
                overall_status = "failed"
            elif pending_checks > 0:
                overall_status = "pending"
            elif passing_checks == total_checks:
                overall_status = "passed"
            else:
                overall_status = "pending"

            return CIStatus(
                overall_status=overall_status,
                checks=checks,
                total_checks=total_checks,
                passing_checks=passing_checks,
                failing_checks=failing_checks,
                pending_checks=pending_checks,
            )

        except Exception as e:
            self.logger.error(
                "Failed to get CI status",
                pr_number=pr_number,
                error=str(e),
                exc_info=True,
            )
            # Return failed status on error
            return CIStatus(
                overall_status="failed",
                checks=[],
                total_checks=0,
            )

    def wait_for_ci(
        self,
        pr_number: int,
        timeout: Optional[int] = None,
    ) -> CIMonitorResult:
        """Wait for CI checks to complete.

        Args:
            pr_number: PR number to monitor
            timeout: Timeout in seconds (default: self.default_timeout)

        Returns:
            CIMonitorResult with final status
        """
        timeout = timeout or self.default_timeout
        start_time = datetime.now(timezone.utc)

        self.logger.info(
            "Starting CI monitoring",
            pr_number=pr_number,
            timeout=timeout,
            poll_interval=self.poll_interval,
        )

        self.total_prs_monitored += 1

        try:
            # Initial status check
            ci_status = self.get_ci_status(pr_number)

            # If no checks, consider it passed
            if ci_status.overall_status == "no_checks":
                self.logger.warning(
                    "No CI checks found for PR",
                    pr_number=pr_number,
                )
                self.prs_passed += 1
                return CIMonitorResult(
                    pr_number=pr_number,
                    ci_status=ci_status,
                    success=True,
                    wait_time=0.0,
                )

            # Poll until complete or timeout
            while True:
                elapsed = (datetime.now(timezone.utc) - start_time).total_seconds()

                # Check for timeout
                if elapsed >= timeout:
                    self.logger.warning(
                        "CI monitoring timed out",
                        pr_number=pr_number,
                        elapsed=elapsed,
                        timeout=timeout,
                    )
                    self.prs_timed_out += 1

                    return CIMonitorResult(
                        pr_number=pr_number,
                        ci_status=ci_status,
                        success=False,
                        timed_out=True,
                        wait_time=elapsed,
                        error=f"CI checks timed out after {elapsed:.0f}s",
                    )

                # Check if all checks are complete
                if ci_status.is_all_passing():
                    self.logger.info(
                        "All CI checks passed",
                        pr_number=pr_number,
                        elapsed=elapsed,
                        total_checks=ci_status.total_checks,
                    )
                    self.prs_passed += 1

                    self.logger.audit(
                        EventType.PR_CI_PASSED,
                        f"CI checks passed for PR #{pr_number}",
                        resource_type="pr",
                        resource_id=str(pr_number),
                        metadata={
                            "total_checks": ci_status.total_checks,
                            "wait_time": elapsed,
                        },
                    )

                    return CIMonitorResult(
                        pr_number=pr_number,
                        ci_status=ci_status,
                        success=True,
                        wait_time=elapsed,
                    )

                elif ci_status.has_failures():
                    self.logger.warning(
                        "CI checks failed",
                        pr_number=pr_number,
                        failing_checks=ci_status.failing_checks,
                        total_checks=ci_status.total_checks,
                    )
                    self.prs_failed += 1

                    self.logger.audit(
                        EventType.PR_CI_FAILED,
                        f"CI checks failed for PR #{pr_number}",
                        resource_type="pr",
                        resource_id=str(pr_number),
                        metadata={
                            "failing_checks": ci_status.failing_checks,
                            "total_checks": ci_status.total_checks,
                        },
                    )

                    return CIMonitorResult(
                        pr_number=pr_number,
                        ci_status=ci_status,
                        success=False,
                        wait_time=elapsed,
                        error=f"{ci_status.failing_checks} of {ci_status.total_checks} checks failed",
                    )

                # Still pending, log progress and wait
                self.logger.debug(
                    "CI checks still pending",
                    pr_number=pr_number,
                    pending_checks=ci_status.pending_checks,
                    passing_checks=ci_status.passing_checks,
                    elapsed=elapsed,
                )

                # Wait before next poll
                import time

                time.sleep(self.poll_interval)

                # Refresh status
                ci_status = self.get_ci_status(pr_number)

        except Exception as e:
            self.logger.error(
                "Error monitoring CI",
                pr_number=pr_number,
                error=str(e),
                exc_info=True,
            )
            self.prs_failed += 1

            return CIMonitorResult(
                pr_number=pr_number,
                ci_status=CIStatus(overall_status="failed"),
                success=False,
                error=str(e),
            )

    def _parse_datetime(self, dt_str: Optional[str]) -> Optional[datetime]:
        """Parse datetime string from GitHub API.

        Args:
            dt_str: ISO format datetime string

        Returns:
            Parsed datetime or None
        """
        if not dt_str:
            return None

        try:
            from dateutil import parser

            return parser.parse(dt_str)
        except Exception:
            return None

    def get_statistics(self) -> Dict[str, Any]:
        """Get CI monitoring statistics.

        Returns:
            Dictionary with statistics
        """
        success_rate = (
            (self.prs_passed / self.total_prs_monitored * 100)
            if self.total_prs_monitored > 0
            else 0.0
        )

        timeout_rate = (
            (self.prs_timed_out / self.total_prs_monitored * 100)
            if self.total_prs_monitored > 0
            else 0.0
        )

        return {
            "total_prs_monitored": self.total_prs_monitored,
            "prs_passed": self.prs_passed,
            "prs_failed": self.prs_failed,
            "prs_timed_out": self.prs_timed_out,
            "success_rate": success_rate,
            "timeout_rate": timeout_rate,
        }

    def reset_statistics(self):
        """Reset CI monitoring statistics."""
        self.total_prs_monitored = 0
        self.prs_passed = 0
        self.prs_failed = 0
        self.prs_timed_out = 0


@dataclass
class CodeReviewResult:
    """Result of code review process."""

    pr_number: int
    review_result: PRReviewResult
    success: bool
    work_item_updated: bool = False
    github_comment_posted: bool = False
    error: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "pr_number": self.pr_number,
            "review_result": (
                self.review_result.to_dict() if self.review_result else None
            ),
            "success": self.success,
            "work_item_updated": self.work_item_updated,
            "github_comment_posted": self.github_comment_posted,
            "error": self.error,
        }


class CodeReviewer:
    """Integrates multi-agent-coder for automated code review.

    Responsibilities:
    - Execute multi-agent-coder on PR branches
    - Pass PR context (diff, files changed, description)
    - Parse and structure review results
    - Post review feedback to GitHub
    - Update work items with review status
    - Log reviews to audit trail
    """

    def __init__(
        self,
        multi_agent_client: MultiAgentCoderClient,
        github_client: GitHubClient,
        git_ops: GitOps,
        logger: AuditLogger,
        review_timeout: int = 600,
    ):
        """Initialize code reviewer.

        Args:
            multi_agent_client: Multi-agent-coder client
            github_client: GitHub API client
            git_ops: Git operations client
            logger: Audit logger
            review_timeout: Timeout for reviews in seconds
        """
        self.multi_agent_client = multi_agent_client
        self.github_client = github_client
        self.git_ops = git_ops
        self.logger = logger
        self.review_timeout = review_timeout

        # Statistics
        self.total_reviews = 0
        self.approved_reviews = 0
        self.rejected_reviews = 0
        self.failed_reviews = 0

    def review_pull_request(
        self,
        pr_number: int,
        work_item: Optional[WorkItem] = None,
        post_comment: bool = True,
    ) -> CodeReviewResult:
        """Review a pull request using multi-agent-coder.

        Args:
            pr_number: PR number to review
            work_item: Optional work item to update with review status
            post_comment: Whether to post review as GitHub comment

        Returns:
            CodeReviewResult with review outcome
        """
        self.logger.info(
            "Starting code review",
            pr_number=pr_number,
            reviewer="multi-agent-coder",
        )

        self.total_reviews += 1

        try:
            # Fetch PR details from GitHub
            pr = self.github_client.get_pull_request(pr_number)
            pr_description = pr.body or ""

            # Get PR diff
            pr_diff = self._get_pr_diff(pr_number)

            # Get list of changed files
            files_changed = self._get_changed_files(pr_number)

            # Execute review using multi-agent-coder
            review_result = self.multi_agent_client.review_pull_request(
                pr_diff=pr_diff,
                pr_description=pr_description,
                files_changed=files_changed,
                pr_number=pr_number,
                timeout=self.review_timeout,
            )

            # Update statistics
            if review_result.approved:
                self.approved_reviews += 1
            else:
                self.rejected_reviews += 1

            # Post review comment to GitHub if requested
            github_comment_posted = False
            if post_comment:
                github_comment_posted = self._post_review_comment(
                    pr_number, review_result
                )

            # Update work item if provided
            work_item_updated = False
            if work_item:
                work_item_updated = self._update_work_item(work_item, review_result)

            # Log review to audit trail
            self.logger.audit(
                (
                    EventType.PR_REVIEWED
                    if review_result.approved
                    else EventType.PR_REVIEW_FAILED
                ),
                f"Code review {'approved' if review_result.approved else 'requested changes'} for PR #{pr_number}",
                resource_type="pr",
                resource_id=str(pr_number),
                metadata={
                    "approved": review_result.approved,
                    "reviewer": review_result.reviewer,
                    "providers_reviewed": review_result.providers_reviewed,
                    "approval_count": review_result.approval_count,
                    "total_reviewers": review_result.total_reviewers,
                    "comments_count": len(review_result.comments),
                    "total_tokens": review_result.total_tokens,
                    "total_cost": review_result.total_cost,
                },
            )

            return CodeReviewResult(
                pr_number=pr_number,
                review_result=review_result,
                success=True,
                work_item_updated=work_item_updated,
                github_comment_posted=github_comment_posted,
            )

        except Exception as e:
            self.failed_reviews += 1
            self.logger.error(
                "Code review failed",
                pr_number=pr_number,
                error=str(e),
                exc_info=True,
            )

            return CodeReviewResult(
                pr_number=pr_number,
                review_result=None,
                success=False,
                error=str(e),
            )

    def _get_pr_diff(self, pr_number: int) -> str:
        """Get full diff for a PR.

        Args:
            pr_number: PR number

        Returns:
            Full PR diff as string
        """
        try:
            pr = self.github_client.get_pull_request(pr_number)

            # Get diff from GitHub API
            # Note: PyGithub doesn't directly expose diff, so we use the API
            diff_url = pr.diff_url
            import requests

            response = requests.get(
                diff_url, headers={"Authorization": f"token {self.github_client.token}"}
            )
            response.raise_for_status()

            return response.text

        except Exception as e:
            self.logger.warning(
                "Failed to get PR diff, using git diff instead",
                pr_number=pr_number,
                error=str(e),
            )

            # Fallback: use git diff
            pr = self.github_client.get_pull_request(pr_number)
            base_branch = pr.base.ref
            head_branch = pr.head.ref

            try:
                diff_output = self.git_ops.run_command(
                    f"git diff origin/{base_branch}...{head_branch}"
                )
                return diff_output
            except Exception as git_error:
                self.logger.error(
                    "Failed to get diff via git",
                    error=str(git_error),
                    exc_info=True,
                )
                return ""

    def _get_changed_files(self, pr_number: int) -> List[str]:
        """Get list of files changed in a PR.

        Args:
            pr_number: PR number

        Returns:
            List of file paths
        """
        try:
            pr = self.github_client.get_pull_request(pr_number)
            files = pr.get_files()
            return [f.filename for f in files]

        except Exception as e:
            self.logger.error(
                "Failed to get changed files",
                pr_number=pr_number,
                error=str(e),
                exc_info=True,
            )
            return []

    def _post_review_comment(
        self, pr_number: int, review_result: PRReviewResult
    ) -> bool:
        """Post review feedback as GitHub comment.

        Args:
            pr_number: PR number
            review_result: Review result to post

        Returns:
            True if comment posted successfully
        """
        try:
            # Format review comment
            comment = self._format_review_comment(review_result)

            # Post as PR comment
            pr = self.github_client.get_pull_request(pr_number)
            pr.create_issue_comment(comment)

            self.logger.info(
                "Posted review comment to PR",
                pr_number=pr_number,
            )
            return True

        except Exception as e:
            self.logger.warning(
                "Failed to post review comment",
                pr_number=pr_number,
                error=str(e),
            )
            return False

    def _format_review_comment(self, review_result: PRReviewResult) -> str:
        """Format review result as GitHub comment.

        Args:
            review_result: Review result to format

        Returns:
            Formatted comment text
        """
        # Header with decision
        decision_emoji = "âœ…" if review_result.approved else "âš ï¸"
        decision_text = "APPROVED" if review_result.approved else "CHANGES REQUESTED"

        comment_lines = [
            f"## {decision_emoji} Code Review: {decision_text}",
            "",
            f"**Reviewed by:** {review_result.reviewer}",
            f"**Providers:** {', '.join(review_result.providers_reviewed)}",
            f"**Approval:** {review_result.approval_count}/{review_result.total_reviewers} providers approved",
            "",
        ]

        # Add summary
        if review_result.summary:
            comment_lines.extend(
                [
                    "### Summary",
                    "",
                    review_result.summary,
                    "",
                ]
            )

        # Add specific comments if present
        if review_result.comments:
            comment_lines.extend(
                [
                    "### Specific Feedback",
                    "",
                ]
            )

            # Group comments by severity
            errors = [c for c in review_result.comments if c.severity == "error"]
            warnings = [c for c in review_result.comments if c.severity == "warning"]
            info = [c for c in review_result.comments if c.severity == "info"]

            if errors:
                comment_lines.append("#### ðŸ”´ Issues")
                for comment in errors:
                    file_ref = (
                        f"`{comment.file}:{comment.line}`"
                        if comment.file
                        else "General"
                    )
                    comment_lines.append(
                        f"- **{file_ref}** ({comment.provider}): {comment.message}"
                    )
                comment_lines.append("")

            if warnings:
                comment_lines.append("#### ðŸŸ¡ Warnings")
                for comment in warnings:
                    file_ref = (
                        f"`{comment.file}:{comment.line}`"
                        if comment.file
                        else "General"
                    )
                    comment_lines.append(
                        f"- **{file_ref}** ({comment.provider}): {comment.message}"
                    )
                comment_lines.append("")

            if info:
                comment_lines.append("#### ðŸ’¡ Suggestions")
                for comment in info[:5]:  # Limit to 5 suggestions
                    file_ref = (
                        f"`{comment.file}:{comment.line}`"
                        if comment.file
                        else "General"
                    )
                    comment_lines.append(
                        f"- **{file_ref}** ({comment.provider}): {comment.message}"
                    )
                if len(info) > 5:
                    comment_lines.append(f"- ... and {len(info) - 5} more suggestions")
                comment_lines.append("")

        # Footer
        comment_lines.extend(
            [
                "---",
                f"*Review completed at {review_result.reviewed_at.strftime('%Y-%m-%d %H:%M:%S UTC')}*",
                f"*Cost: ${review_result.total_cost:.4f} | Tokens: {review_result.total_tokens:,}*",
            ]
        )

        return "\n".join(comment_lines)

    def _update_work_item(
        self, work_item: WorkItem, review_result: PRReviewResult
    ) -> bool:
        """Update work item with review status.

        Args:
            work_item: Work item to update
            review_result: Review result

        Returns:
            True if updated successfully
        """
        try:
            # Update metadata
            work_item.metadata["review_status"] = (
                "approved" if review_result.approved else "changes_requested"
            )
            work_item.metadata["review_providers"] = review_result.providers_reviewed
            work_item.metadata["review_approval_count"] = review_result.approval_count
            work_item.metadata["review_total_reviewers"] = review_result.total_reviewers
            work_item.metadata["review_comments_count"] = len(review_result.comments)
            work_item.metadata["review_cost"] = review_result.total_cost

            return True

        except Exception as e:
            self.logger.warning(
                "Failed to update work item with review status",
                work_item_id=work_item.item_id,
                error=str(e),
            )
            return False

    def get_statistics(self) -> Dict[str, Any]:
        """Get code review statistics.

        Returns:
            Dictionary with statistics
        """
        approval_rate = (
            (self.approved_reviews / self.total_reviews * 100)
            if self.total_reviews > 0
            else 0.0
        )

        return {
            "total_reviews": self.total_reviews,
            "approved_reviews": self.approved_reviews,
            "rejected_reviews": self.rejected_reviews,
            "failed_reviews": self.failed_reviews,
            "approval_rate": approval_rate,
        }

    def reset_statistics(self):
        """Reset code review statistics."""
        self.total_reviews = 0
        self.approved_reviews = 0
        self.rejected_reviews = 0
        self.failed_reviews = 0
